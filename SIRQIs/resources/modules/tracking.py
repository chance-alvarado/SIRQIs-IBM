"""Class to track progress on number of time steps and simulations completed.When a script with a ProgressBar object is exectued within a terminal,progress bars are initialized and updated based on passed dictionary values.If the script initializing the ProgressBar object is run through an IDE suchas Spyder, progress tracking is supressed. Compatibility may be limiteddepending on the local operating system.An example progress bar is shown below:|---------------------------------------------------------------------------||                               SIRQIs IBM                                  ||---------------------------------------------------------------------------||Simulations run: 8/10           (80%) |[###########################-------]||Days elapsed: 27/100            (27%) |[#########-------------------------]||---------------------------------------------------------------------------|More information can be found in this project's README file.Explore this repository at:    https://github.com/chance-alvarado/SIRQIs-IBM/Author:    Chance Alvarado        LinkedIn: https://www.linkedin.com/in/chance-alvarado/        GitHub: https://github.com/chance-alvarado/"""# Importsimport sys# Class to define progress tracker dynamicsclass ProgressTracker():    """Define class for progress tracker dynamics."""    def __init__(self, title_str, progress_dict, max_line=77, num_in_bar=34):        """Initialize necessary attributes."""        # Determine if displayed in console and supress output if needed        if sys.stdout.isatty():            self.supress_output = False        else:            self.supress_output = True            return        # Maximum length of figure        self.max_line = max_line        # Number of discrete spaces to divide bar into        self.num_in_bar = num_in_bar        # Line break to separate sections        self.line_break = ''.join(['|',  (max_line - 2) * '-', '|'])        # Formatted title string        self.title = ''.join(['|', title_str.center(max_line - 2), '|'])        # Number of lines to erase        self.num_to_erase = 4 + len(progress_dict)        # Start on new line        print('\n')        # Display current line without erasing any output        self.update(progress_dict, clear_previous=False)    def progress_bar_string(self, section_str, current_num, total_num):        """Construct single progress bar as a formatted string."""        # Portion of bar to be filled/unfilled        num_filled = int(current_num / total_num * self.num_in_bar)        num_unfilled = int(self.num_in_bar - num_filled)        # Rounded percent        percent = int((current_num / total_num) * 100)        # Individual components of progress bar line        section_title = ''.join(['|', str(section_str), ': ', str(current_num),                                 '/', str(total_num)])        progress_bar = ''.join(['(', str(percent).zfill(2), '%) |[',                                (num_filled * '#'), (num_unfilled * '-'),                                ']|'])        # Format line        line = ''.join([section_title, (self.max_line                                        - len(section_title)                                        - len(progress_bar)) * ' ',                        progress_bar])        # Return formatted line        return line    def update(self, progress_dict, clear_previous=True):        """Update progress bars based on progress_dict."""        # If supressed, break        if self.supress_output:            return        # List of formatted progress bars        lines = [self.line_break, self.title, self.line_break]        # Iterate through all keys in in progress_dict        for key in progress_dict.keys():            # Update output with progress bar            lines.append(self.progress_bar_string(key, *progress_dict[key]))        # Append a final line break and blank line        lines.append(self.line_break)        lines.append('')        # Format output        output = '\n'.join(lines)        # Clear previous output if needed        if clear_previous:            for i in range(self.num_to_erase + 1):                print('\x1b[2A', '\x1b[2K')        # Display updated output        print(output)